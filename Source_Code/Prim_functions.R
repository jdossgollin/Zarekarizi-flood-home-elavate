##==============================================================================
##
## Script to define functions needed by PRIM
#
## code adopted (and slightly modified) from 
## Hadka, D., Herman, J., Reed, P., Keller, K., 2015. 
## An open source framework for many-objective robust decision making. 
## Environtl Modeling and Softw. 74, 114â€“129. https://doi.org/10.1016/J.ENVSOFT.2015.07.014
##==============================================================================

# Load libraries
library(prim)

# Start funcitons
##########################################################################
##########################################################################
##########################################################################
mordm.plot.box <- function(data, mark, main="", scale.width=TRUE, bar.width=3, col='gray', names=NULL, legend=FALSE, defaults=NULL) {
  nvars <- attr(data, "nvars")
  bounds <- attr(data, "bounds")
  
  if (is.null(bounds)) {
    stop("Bounds must be defined for the dataset")
  }
  
  longcol <- par("fg")
  outcol <- "transparent"
  
  # reset plot settings
  #  if (exists("default.par", mordm.globals)) {
  #    par(get("default.par", mordm.globals))
  #  } else {
  #    assign("default.par", par(no.readonly=TRUE), mordm.globals)
  #  }
  
  if (legend) {
    layout(c(1,2), heights=c(7,1))
  }
  
  par(xpd=TRUE, mar=c(4.1, 2.1, 4.1, 2.1))
  
  # create the plot
  barplot(matrix(rep(1,3*nvars),ncol=nvars), add=FALSE, main=main, col="transparent", beside=TRUE, width=1, 
          names.arg=rep("",nvars), axes=FALSE, space=c(0,3), border=c("transparent",longcol,"transparent"))
  
  if (!is.list(mark)) {
    mark = list(mark)
  }
  
  if (is.null(col)) {
    colors <- rainbow(length(mark), v=0.9)
  } else {
    colors <- col
  }
  
  for (i in 1:length(mark)) {
    # allow each mark to either be a single PRIM box or a group of boxes
    if (is.list(mark[[i]])) {
      mark.as.list <- unlist(mark[[i]])
    } else {
      mark.as.list <- list(mark[[i]])
    }
    
    # display each box in the group
    for (j in 1:length(mark.as.list)) {
      box <- attr(mark.as.list[[j]], "box")
      
      if (is.null(box)) {
        warning("Given mark was not generated by PRIM")
        next
      }
      
      # scale the box dimensions
      values <- sapply(1:nvars, function(i) (box[,i]-bounds[1,i]) / (bounds[2,i]-bounds[1,i]))
      
      # ensure the scaled values do not exceed the variable bounds (PRIM boxes can
      # extend outside the bounds)
      values[1,] <- sapply(1:nvars, function(i) max(values[1,i], 0))
      values[2,] <- sapply(1:nvars, function(i) min(values[2,i], 1))
      
      # create the matrix that is plotted, row1=outside, row2=inside, row3=outside
      mat <- rbind(values[1,], values[2,]-values[1,], 1-values[2,])
      colnames(mat) <- colnames(box)
      
      width <- ifelse(scale.width, bar.width/i, bar.width)
      spacer <- bar.width - width
      space <- append(1+spacer, rep(1+(4/3)*spacer, nvars-1))
      
      barplot(mat[,1:nvars],
              add=TRUE,
              
              col=c(outcol,colors[i],outcol),
              border=NA,
              names.arg=rep("",nvars),
              axes=FALSE,
              main="",
              width=width,
              space=space)
    }
  }
  
  axis(1,at = seq(4.5,by=6,length.out=nvars),labels=colnames(mat[,1:nvars]),las=1, line=2)
  text(seq(4.5,by=6,length.out=nvars), y=rep(1, nvars), pos=3, labels=sprintf("%g", bounds[2,]), cex=0.8)
  text(seq(4.5,by=6,length.out=nvars), y=rep(0, nvars), pos=1, labels=sprintf("%g", bounds[1,]), cex=0.8)
  
  if (!is.null(defaults)) {
    segments(seq(4.5,by=6,length.out=nvars)-1.5, (defaults-bounds[1,])/(bounds[2,]-bounds[1,]), seq(4.5,by=6,length.out=nvars)+1.45, (defaults-bounds[1,])/(bounds[2,]-bounds[1,]), lwd=3)
  }
  
  # create the legend
  if (legend) {
    par(mar=c(0,0,0,0))
    plot.new()
    
    if (is.null(names)) {
      names <- sprintf("Box %i", 1:length(mark))
    }
    
    #    legend("center",
    #           legend=names,
    #           fill=colors,
    #           bty="o",
    #           cex=1.0,
    #           horiz=TRUE,
    #           xjust=0.5)
  }
}

##########################################################################
##########################################################################
##########################################################################

mordm.mark.box <- function(box, mean, mass) {
  result <- mordm.mark.rule(function(x) {
    names <- colnames(box)
    all(sapply(1:length(names), function(i) x[names[i]] >= box[1,names[i]] & x[names[i]] <= box[2,names[i]]))
  })
  
  attr(result, "mean") <- mean
  attr(result, "mass") <- mass
  attr(result, "box") <- box
  return(result)
}
##########################################################################
##########################################################################
##########################################################################

mordm.mark.rule <- function(condition) {
  mark <- condition
  class(mark) <- "mark"
  return(mark)
}
##########################################################################
##########################################################################
##########################################################################

analyze.prim <- function(factors, response, bounds=NULL, which.box=1, show.plot=TRUE, method="prim", ...) {
  if (method == "prim") {
    box <- prim.box(factors, response, ...)
    
    marks <- lapply(1:box$num.hdr.class, function(i) {
      i <- eval(i)
      colnames(box$box[[i]]) <- colnames(factors)
      mordm.mark.box(box$box[[i]], box$y.fun[i], box$mass[i])
    })
    
    if (is.null(bounds)) {
      bounds <- apply(factors, 2, range)
    }
    
    dummy.data <- list()
    attr(dummy.data, "nvars") <- ncol(factors)
    attr(dummy.data, "bounds") <- bounds
    mordm.plot.box(dummy.data, marks[[which.box]])
    
    # compute density and coverage of the box
    varargs <- list(...)
    varargs=NULL
    if (is.null(varargs$threshold.type) || varargs$threshold.type==0) {
      
    } else if (varargs$threshold.type == -1) {
      threshold <- mean(response)
      total.interesting = sum(response <= threshold)
      
      captured.indices <- mordm.select.indices(factors, mordm.mark.union(marks))
      captured.interesting = sum(response[captured.indices] <= threshold)
      
      cat("Coverage: ")
      cat(captured.interesting / total.interesting)
      cat("\n")
      cat("Density: ")
      cat(captured.interesting / length(captured.indices))
      cat("\n")
    } else {
      threshold <- mean(response)
      total.interesting = sum(response >= threshold)
      
      captured.indices <- mordm.select.indices(factors, mordm.mark.union(marks))
      captured.interesting = sum(response[captured.indices] >= threshold)
      
      cat("Coverage: ")
      cat(captured.interesting / total.interesting)
      cat("\n")
      cat("Density: ")
      cat(captured.interesting / length(captured.indices))
      cat("\n")
    }
    
    invisible(marks)
  } else if (method == "sdprim") {
    if (packageVersion("sdtoolkit") > '2.31') {
      warning("Newer version of sdtoolkit have known errors.  Please use version 2.31 or before.")
    } else if (Sys.getenv("RSTUDIO") == "1") {
      warning("sdtoolkit often causes RStudio to crash.  Please run PRIM from the console.")
    }
    
    require(sdtoolkit)
    sdprim(factors, response, ...)
  } else {
    warning("Unknown PRIM method, must be 'prim' or 'sdprim'")
  }
}
##########################################################################
##########################################################################
##########################################################################
